<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 14pt;
    }
  </style>
</head>
<body>
<a name="1697"/>

<div>
<span><div><span style="font-size: 16px;"><br/></span></div><div style="font-style: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">1、什么是设计模式？</span></div><div><span style="font-size: 16px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);"><div><span style="font-size: 16px;">设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。   设计模式就是一种 编程规范  架构层面的</span></div></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">2、设计模式之单例模式</span></div><div><span style="font-size: 16px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);"><div><span style="font-size: 16px;">单例：对象只能实例化(创建)一次就叫单例</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">单例模式：字面量的对象声明{}，其实在设计模式中可以看作是一种单例模式，所谓单例模式，就是永远保持对象的一个实例。</span></div><div><span style="font-size: 16px;">var  obj= new Object();</span></div><div><span style="font-size: 16px;">var obj = {};</span></div><div><span style="font-size: 16px;">obj = {}    一次只能创建一个对象  -    单例模式</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">     //实现单利模式</span></div><div><span style="font-size: 16px;">     //  实现思路：  将第一次new出来的对象 this  保存到一个变量中 ，返回这个变量</span></div><div><span style="font-size: 16px;">     //再次创建对象时，判断  这个变量中是否含有值，如果有值，就直接将这个变量返回</span></div><div><span style="font-size: 16px;">   </span></div><div><span style="font-size: 16px;">     <br/></span></div><div><span style="font-size: 16px;">     function MyPlane(){</span></div><div><span style="font-size: 16px;">          if( MyPlane.instance ){  //在构造函数内部    可以为构造函数指定任意一个属性 用来接收值</span></div><div><span style="font-size: 16px;">               return MyPlane.instance;<br/></span></div><div><span style="font-size: 16px;">          }<br/></span></div><div><span style="font-size: 16px;">          MyPlane.instance = this;</span></div><div><span style="font-size: 16px;">          return MyPlane.instance;<br/></span></div><div><span style="font-size: 16px;">     }    </span></div><div><span style="font-size: 16px;">     var plane = new MyPlane();<br/></span></div><div><span style="font-size: 16px;">      </span></div></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">3、设计模式之代理模式</span></div><div><span style="font-size: 16px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);"><div><span style="font-size: 16px;">代理模式: 为其他对象提供一种代理，并以控制对这个对象的访问。 (事件委托 li  Ul)</span></div><div><span style="font-size: 16px;"> </span></div></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">4、设计模式之适配器模式</span></div><div><span style="font-size: 16px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);"><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 13.3333px;"><span style="font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;"><span style="font-size: 16px;">适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。</span></span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 13.3333px;"><span style="font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;"><span style="font-size: 16px;"><br/></span></span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 13.3333px;"><span style="font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;"><span style="font-size: 16px;">将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</span></span></span></span></div><div>function A(){</div><div>}</div><div>fnuction B(){</div><div><br/></div><div>}</div><div>function Adaper(){  同时操作A类和B类的功能</div><div><br/></div><div>}</div></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">5、设计模式之工厂模式</span></div><div><span style="font-size: 16px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);"><div><span style="font-size: 16px;"><span style="color: rgb(51, 51, 51);">让对象的调用者和对象创建过程分离，当对象调用者需要对象时，直接向工厂请求即可。从而避免了对象的调用者与对象的实现类似编码方</span>式耦合<span style="color: rgb(51, 51, 51);">，以提高系统的可维护性、可扩展性。</span></span></div></div><div><span style="font-size: 16px;"><br/></span></div></div><div style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 13.3333px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;"><span style="font-size: 16px;">6、设计模式之观察者模式</span></div><div style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 13.3333px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;"><span style="font-size: 16px;"><br/></span></div><div style="font-style: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);"><div><span style="font-size: 16px;">观察者模式又叫发布订阅模式（Publish/Subscribe），它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">时间到了  --  放学了</span></div><div><span style="font-size: 16px;">半夜12点了  --  该通宵了</span></div><div><span style="font-size: 16px;">小孩哭了  ---  喂奶了 </span></div></div><div style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 13.3333px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;"><br/></div><div style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 13.3333px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;"><span style="font-size: 16px;">7、策略模式</span></div><div style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 13.3333px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;"><span style="font-size: 16px;"><br/></span></div><div style="font-style: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);"><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-style: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div><span style="font-size: 16px;">定义一系列算法，把他们一个一个封装起来，并且使他们可以相互替换(具有相同的目标和意图)</span></div></div></div><div><br/></div><div>8、闭包</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="color: rgb(51, 51, 51);"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="font-size: 16px;">什么是闭包？</span></span></span></div><div><span style="font-size: 16px;"><font color="#95A3AB" face="Consolas"><span style="background-color: rgb(255, 250, 232); background-position: initial initial; background-repeat: initial initial;">一个函数返回一个匿名函数，这个匿名函数就称为闭包</span></font></span></div><div align="left" style="min-height: 18pt;"><div><font color="#95A3AB" face="Consolas" size="4"><span style="font-size:16pt; background:#fffae8">能够访问其它函数内部局部变量的函数，这样的函数就称为闭包    闭包的形式多样 ，但都是局部函数全局执行</span></font></div><div><span style="font-size: 16pt;"><span style="font-family: Consolas;"><span style="background-color: rgb(255, 250, 232);"><span style="color: rgb(149, 163, 171);">闭包作用 ： 通过闭包可以访问一个函数内部的局部变量</span></span></span></span></div><div><span style="font-size: 16pt;"><span style="font-family: Consolas;"><span style="background-color: rgb(255, 250, 232);"><span style="color: rgb(149, 163, 171);">           可以让一个局部变量长期驻留在内存中  </span></span></span></span></div><div><span style="font-size: 16pt;"><span style="font-family: Consolas;"><span style="background-color: rgb(255, 250, 232);"><span style="color: rgb(149, 163, 171);">闭包中的this 指向 window对象  </span></span></span></span></div></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 